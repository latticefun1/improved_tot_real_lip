##########
# Copyright 2024, Guilhem Mureau, Alice Pellet-Mary, Heorhii Pliatsok,
# Alexandre Wallet

# This file is part of the algorithm to solve Module-LIP in rank 2
# over totally real fields, called for referencing reason
# ModLipAttack. ModLipAttack is free software: you can redistribute it
# and/or modify it under the terms of the GNU Affero Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.  ModLipAttack is
# distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero Public License
# for more details.  You should have received a copy of the GNU Affero
# Public License along with ModLipAttack. If not, see
# <https://www.gnu.org/licenses/>

##########

#####################################################################
## This file runs the attack against the Hawk signature scheme when
## instantiated over totally real number fields (TODO add eprint 
## reference when available).
## The file contains two functions to generate the parameters and
## the challenge for the attack. It then runs the attack on the
## generated challenge.
##
## /!\ The attack is only guaranteed to work for totally real subfields K of
## a cyclotomic field L whose conductor is *a multiple of 4*. /!\
##
## When this is the case L = K(i) is the cyclotomic field of conductor m, and the 
## Gentry-Szydlo algorithm has been implemented (and many computations 
## can be fastened). Some of the intermediate functions can handle more 
## generic fields but they will likely be much slower (e.g., they use 
## sage's PIP solver instead of the Gentry-Szydlo algorithm). 
## And we do not provide an end-to-end attack for fields of 
## conductor != 0 mod 4.
##
##
## You might want to modify this file at two places:
##  - the quantity pari_size_max should be replaced by the maximum amount 
## of RAM you can spare for the computation. The default value is 5 GB
##  (you can put it much smaller for small conductors, e.g., up to m = 128)
##  - if you have an installation of pari/gp on your computer which has 
## version 2.16.x or later AND if your installation of sagemath has access
## to a version of pari which is 2.15.x or before (you can check this by 
## running pari.version() in sage), you may want to use the most recent 
## version of pari/gp for the computation, which contains an implementation 
## of the flatter LLL algorithm (this improves computation time by roughly 
## 20/30% for reasonnable dimensions). To use your most recent installation
## of pari/gp, replace the line path_to_pari = None, by the actual path to 
## your gp executable. If you do so, you might also want to modify the
## default parisizemax and threadsizemax in the file Gentry_Szydlo/LLL_gram_pari.gp
## (more information about these parameters in the file LLL_gram_pari.gp)
##############################################

import time
load("congruence.sage")

########## FUNCTIONS

######################################
## The two functions below are used
## to generate the parameters and the
## challenge input.
## They mimic Hawk's key generation
## over a totally real number field
######################################

def NiceOKBasis(K, L):
    # L is a cyclotomic field of conductor m = 4k, K is the maximal totally real subfield
    # OK is generated by the power basis (zeta+zeta^-1)^i, but it has less nice geometry that the basis zeta^i + zeta^-i
    # This function outputs the latter basis via a triangular change of basis (this avoids casting it from L to K)

    T = [ [ 0 for _ in range(K.degree()) ] for _ in range(K.degree()) ]
    for i in range(K.degree()):
        T[i][i] = 1
        
    for i in range(2, K.degree()):
        for j in range(i):
            if(j%2 == i%2):
                T[i][j] = binomial(i, (i-j)/2)
                
    T = Matrix(T)
    Chg = T.inverse()
    B_OK = [ K(e) for e in Chg ]
    return (B_OK,T)

def FakeHawkKeyGen(K, C, MC_, bo, Hawk=True):
    # return a Hawk-like matrix but over a totally really field
    # bo is a bound on the entries of the first column
    # basically, it's Cohen algorithm to complete a basis of a rank 2 module
    # (see also: NTRU solve)
    # C should be the basis for K
    # MC_ is the matrix of the inverse of C

    if(Hawk==False):
        while(True):
            a, b, c, d = [ K( [ randint(-bo, bo+1) for i in range(K.degree()) ] ) for _ in range(4) ]
            if(a*d-b*c != 0):
                break
        return Matrix( [ [a, c], [b ,d] ] )
    
    s = K.gen()
    a = sum( [ randint(-bo, bo+1)*s^i for i in range(K.degree()) ] )
    A = a.matrix().LLL()
    while True:
        # we try to find a coprime principal ideal
        b = sum( [ randint(-bo, bo+1)*s^i for i in range(K.degree()) ] )
        B = b.matrix().LLL()
        A_B = block_matrix( [ [A], [B] ] ).change_ring(ZZ)
        H,T = A_B.hermite_form(transformation=True) # will be long for large field
        if(H[0:K.degree()]==identity_matrix(K.degree())):
            break
    # (a) and (b) are coprime, we can find ad-bc = 1    
    d = K(T[0][0:K.degree()]*A)/a
    c = -K(T[0][K.degree():2*K.degree()]*B)/b

    # Now we algebraically size-reduce according to the chosen basis of K   
    mu = (a*c+b*d)/(a^2+b^2)
    coord_mu = vector(mu)*MC_
    mu_round = sum( round(coord_mu[i])*C[i] for i in range(K.degree()) )
    c_red = c - mu_round * a
    d_red = d - mu_round * b

    return Matrix( [ [ a, c_red ], [ b, d_red ] ] )


########## RUNNING THE ATTACK

###################################################
## You may want to modify the two quantities below
####################################################
## Update the two quantities below to fit your machine
pari_size_max = 5*2^30 ## 2^30 is a Go of memory -> update this value, depending on how much RAM you can spare for the computation. Pari will not allocate all this memory by default, but it will increase the size of its memory if needed, until reaching this maximum. If the code crashes with a "PARI stack overflows" error, consider increasing this value.

path_to_pari = None ## Update here with your own path to gp if you want to use a specific version of pari, e.g., path_to_pari = "~/pari/GPDIR/bin/gp" 

## Generating the parameters of the attack
## /!\ m should be a multiple of 4 for the implementation to work /!\
m = 4*16 ## conductor of the cyclotomic field in which we run the attack, should be a multiple of 4

path_to_GS = "Gentry_Szydlo/"
pari.allocatemem(s = pari.stacksize(), sizemax = pari_size_max)
L = CyclotomicField(m)
(K, phi) = L.maximal_totally_real_subfield()
print("\nMaximal totally real subfield of a cyclotomic field of conductor",m)
print("The dimension of the module lattices involved is", euler_phi(m)," (over ZZ)")
    
print("\nComputing a basis of OK and its inverse...")
t1 = time.time()
B_OK, MC_ = NiceOKBasis(K, L)
t2 = time.time()
print("...done computing a basis of OK and its inverse")
print("(this took time:", Reals(20)(t2-t1),"seconds)")

## Creating the challenge Gram matrix (in Hawk's way)
print("\nCreating the challenge instance...")
t1 = time.time()
B = FakeHawkKeyGen(K, B_OK, MC_, 3, Hawk=True)
Q = B.T*B
t3 = time.time()
print("...done creating the challenge instance")
print("(this took", Reals(20)(t3-t1), "seconds)\n")

print("\nStarting the attack...")
t1 = time.time()
sols = CongruenceSolver(Q, K, L, B_OK, phi = phi, path_to_pari = path_to_pari, path_to_GS = path_to_GS) ## you can add verb = True here is you want more informations on the on-going computations
t2 = time.time()
print("...the attack is over")
print("(this took", Reals(20)(t2-t1), "seconds)\n")
print("The attack created a list of", len(sols), "bases")
if B in sols:
  print("and the original basis is part of it (attack successful!)")
else:
  print("and the original basis is *not* part of it (attack failed...)")

