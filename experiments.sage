import time
load("congruence.sage")


def NiceOKBasis(K, L):
    # L is a cyclotomic field of conductor m = 4k, K is the maximal totally real subfield
    # OK is generated by the power basis (zeta+zeta^-1)^i, but it has less nice geometry that the basis zeta^i + zeta^-i
    # This function outputs the latter basis via a triangular change of basis (this avoids casting it from L to K)

    T = [ [ 0 for _ in range(K.degree()) ] for _ in range(K.degree()) ]
    for i in range(K.degree()):
        T[i][i] = 1
        
    for i in range(2, K.degree()):
        for j in range(i):
            if(j%2 == i%2):
                T[i][j] = binomial(i, (i-j)/2)
                
    T = Matrix(T)
    Chg = T.inverse()
    B_OK = [ K(e) for e in Chg ]
    return (B_OK,T)

def FakeHawkKeyGen(K, C, MC_, bo, Hawk=True):
    # return a Hawk-like matrix but over a totally really field
    # bo is a bound on the entries of the first column
    # basically, it's Cohen algorithm to complete a basis of a rank 2 module
    # (see also: NTRU solve)
    # C should be the basis for K
    # MC_ is the matrix of the inverse of C

    if(Hawk==False):
        while(True):
            a, b, c, d = [ K( [ randint(-bo, bo+1) for i in range(K.degree()) ] ) for _ in range(4) ]
            if(a*d-b*c != 0):
                break
        return Matrix( [ [a, c], [b ,d] ] )
    
    s = K.gen()
    a = sum( [ randint(-bo, bo+1)*s^i for i in range(K.degree()) ] )
    A = a.matrix().LLL()
    while True:
        # we try to find a coprime principal ideal
        b = sum( [ randint(-bo, bo+1)*s^i for i in range(K.degree()) ] )
        B = b.matrix().LLL()
        A_B = block_matrix( [ [A], [B] ] ).change_ring(ZZ)
        H,T = A_B.hermite_form(transformation=True) # will be long for large field
        if(H[0:K.degree()]==identity_matrix(K.degree())):
            break
    # (a) and (b) are coprime, we can find ad-bc = 1    
    d = K(T[0][0:K.degree()]*A)/a
    c = -K(T[0][K.degree():2*K.degree()]*B)/b

    # Now we algebraically size-reduce according to the chosen basis of K   
    mu = (a*c+b*d)/(a^2+b^2)
    coord_mu = vector(mu)*MC_
    mu_round = sum( round(coord_mu[i])*C[i] for i in range(K.degree()) )
    c_red = c - mu_round * a
    d_red = d - mu_round * b

    return Matrix( [ [ a, c_red ], [ b, d_red ] ] )

pari_size_max = 64*2^30
path_to_pari = None

def param(e):
    return (euler_phi(4*e), 4*e, e)

LIST_m  = { 32:[10, [], 0], 64:[10, [], 0], 128:[10, [], 0], 256: [5, [], 0], 512:[5,[],0] }
LIST_m2 = { 32:[10, [], 0], 64:[10, [], 0], 128:[10, [], 0], 256: [5, [], 0], 512:[5,[],0] }

LIST_m  = { 512:[1,[],0] }
LIST_m2 = { 512:[1,[],0] }

#LIST_m = { 4*9:[10, [], 0], 4*13:[10, [], 0], 4*19:[10, [], 0], 4*21:[10, [], 0], 4*26:[10, [], 0], 4*31:[5, [], 0], 4*39:[5, [], 0], 4*45:[5, [], 0], 4*51:[5, [], 0], 4*57:[5, [], 0] }

#LIST_m = { 340:[3, [], 0], 296:[3, [], 0] } #276:[5, [], 0], 260:[5, [], 0],  232:[3, [], 0],

path_to_GS = "Gentry_Szydlo/"

Verb = 0
for m in LIST_m:
    
    pari.allocatemem(s = pari.stacksize(), sizemax = pari_size_max)
    L = CyclotomicField(m)
    print("Running over a field of conductor", m, " and degree", euler_phi(m))
    (K, phi) = L.maximal_totally_real_subfield()

    NTEST = LIST_m[m][0]    
    
    print("\nComputing a basis of OK and its inverse...")
    t1 = time.time()
    B_OK, MC_ = NiceOKBasis(K, L)

    for _ in range(NTEST):
        
        print("\nCreating the challenge instance...")
        t1 = time.time()
        B = FakeHawkKeyGen(K, B_OK, MC_, 3, Hawk=True)
        Q = B.T*B
        t3 = time.time()
        print("...done creating the challence instance")
        print("(this took", Reals(20)(t3-t1), "seconds)\n")

        print("\nStarting the attack using the original algorithm...")
        t1 = time.time()
        sols = CongruenceSolver(Q, K, L, B_OK, phi, path_to_pari = path_to_pari, path_to_GS = path_to_GS, verb=Verb)
        t2 = time.time()
        print("...the attack is over")
        print("(this took", Reals(20)(t2-t1), "seconds)\n")
        if B in sols:
            print("and the original basis is part of it (attack successful!)")
            LIST_m[m][1] += [ Reals(20)(t2-t1) ]
        else:
            print("and the original basis is *not* part of it (attack failed...)")
        
        print("\nStarting the attack using our modified algorithm...")
        t1 = time.time()
        sols2 = CongruenceSolver2(Q, K, L, B_OK, phi, path_to_pari = path_to_pari, path_to_GS = path_to_GS, verb=Verb)
        t2 = time.time()
        print("...the attack is over")
        print("(this took", Reals(20)(t2-t1), "seconds)\n")

        if B in sols2:
            print("and using our algorithm, the original basis is part of it (attack successful!)")
            LIST_m2[m][1] += [ Reals(20)(t2-t1) ]
        else:
            print("and using our modified algorithm,  the original basis is *not* part of it (attack failed...)")

            
    LIST_m[m][2] = sum( LIST_m[m][1] )/NTEST
    LIST_m2[m][2] = sum( LIST_m2[m][1] )/NTEST
    print("Average attack time using the original algorithm for", (m, euler_phi(m)), ":", LIST_m[m][2])
    print("Average attack time using the modified algorithm for", (m, euler_phi(m)), ":", LIST_m2[m][2])
    print("="*100)
    
print( [ LIST_m[e][2] for e in LIST_m ] )
print( [ LIST_m2[e][2] for e in LIST_m2 ] )

