##########
# Copyright 2024, Guilhem Mureau, Alice Pellet-Mary, Heorhii Pliatsok,
# Alexandre Wallet

# This file is part of the algorithm to solve Module-LIP in rank 2
# over totally real fields, called for referencing reason
# ModLipAttack. ModLipAttack is free software: you can redistribute it
# and/or modify it under the terms of the GNU Affero Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.  ModLipAttack is
# distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero Public License
# for more details.  You should have received a copy of the GNU Affero
# Public License along with ModLipAttack. If not, see
# <https://www.gnu.org/licenses/>

##########

#############################################################
## This file contains functions to estimate the size of the
## primes P1 and P2 and the integer Q needed when running 
## the Gentry-Szydlo algorithm
## The function Vandermonde_inv compute a field related
## quantity (rhoughly the ratio between the norm of the field
## elements in coefficients and canonical embeddings). This
## computation can be done once and for all, in order to sage
## some computation time.
#############################################################

def Vandermonde_inv(L):
  ## Input: L is a cyclotomic number field, and OL is assumed to be generated by the power basis (e.g., L is cyclotomic)
  ## Output: the maximum coefficient (in absolute value) of the inverse of the matrix (sigma(x^i))_i, where sigma is the canonical embedding and (x^i) is the basis of OL (where x = L.gen() is a primitive root of unity). This measures how large the coefficient embedding (with respect to the basis (x^i)) of an element x in OL can be, as a function of the norm of its canonical embedding.

  x = L.gen()
  B_OK = [ x^i for i in range(L.degree()) ]
  prec = 5*L.degree() ## increase the precision for accurate matrix inversion when the dimension is large
  V = matrix(ComplexField(prec), [bi.complex_embeddings(prec = prec) for bi in B_OK])
  V_inv = V^(-1)
  max_V_inv = max([vi.norm(infinity) for vi in V_inv]) ## maximum of the coefficients of V_inv
  return RR(max_V_inv)

def estimate_vr(L, max_V_inv, heuristic = "normal"):
  ## Input: L is a cyclotomic number field L
  ##        max_V_inv is the output of Vandermonde_inv(L)
  ##        heuristic can be chosen between "normal", "conservative" and "proven" (default: "normal"). This measure the heuristic level of the bound computed in this function. 
  ##            If heuristic = "proven", then no heuristic is used at all, but the bound is going to be pretty bad, and this will degrade significantly the running time of the algorithm. 
  ##            If heuristic = "conservative" is used, the only heuristic used is the one that says that the first vector of an LLL-reduced basis is at most 1.022^n times larges then the shortest non-zero lattice vector (instead of the prover 2^(n/2)). This is a pretty well established heuristic, validated by numerous experiments.
  ##            If heuristic = "normal", the algorithm uses the heuristic on the output of the LLL algorithm, as well as the heuristic that the vector vr (for which we want to compute an upper bound on the coefficients) is somewhat balanced, meaning that its infinity norm is less than or equal to its l2 norm times log(n)/sqrt(n). This is known to be true if vr is random enough, and seems to hold in almost all our experiments.
  ##             The choice of the heuristic has an impact on the running time of the algorithm, so if a posteriori verification of the result can be done efficiently, it is highly recommended to use the default heuristic = "normal", which should be correct most of the time and will run the fastest.
  ## Output: a (heuristic) upper bound on the infinity norm of the coefficients of vr. Here, vr is the output of the LLL algorithm on input an ideal of norm 1 (in K_R).
  
  n = L.degree()
  DL = abs(L.discriminant())
 
  if heuristic == "normal":
    return RR(1.022^n*sqrt(n/(2*pi*exp(1)))*DL^(1/(2*n))*max_V_inv*log(n)/sqrt(n))
  elif heuristic == "conservative":
    return RR(1.022^n*sqrt(n)*DL^(1/(2*n))*max_V_inv)
  elif heuristic == "proven":
    return RR(2^(n/2)*sqrt(n)*DL^(1/(2*n))*max_V_inv) 
  else:
    ## sqrt(n)*DL^(1/(2*n)) is Minkowski's upper bound on the euclidean norm of the shortest lattice vector (in an ideal of algebraic norm 1) in canonical embedding. Multiplying it by max_V_inv gives an upper bound on the infinity norm of the same vector in coefficient embedding. Multiplying by 2^{n/2} gives an upper bound on the shortest vector output by the LLL algorithm.
    raise ValueError("Parameter heuristic in estimate_vr should be one of either: \'normal\' (default), \'conservative\', or \'proven\'")
    
    
def estimate_s_pow_m(L, m, x, max_V_inv):
  ## Input: L is a cyclotomic field
  ##        x = s*bar(s), where s is the generator we want to recover in the Gentry-Szydlo algorithm
  ##        max_V_inv is the output of Vandermonde_inv(L)
  ##        m is an integer
  ## Output: an upper bound on the size of the coefficients of s^m (in the basis (x^i) of L)
  
  
  abs_s = [sqrt(abs(xi)) for xi in x.complex_embeddings()] ## since x = s*bar(s), this is a vector whose coordinates are the absolute values of the coefficients of s in canonical embedding
  abs_s_pow_m = [si^m for si in abs_s]
  sum_s_pow_m = sum(abs_s_pow_m) ## this is the l1-norm of s^m in canonical embedding. Multiplied by max_V_inv it provides an upper bound on the infinity norm of s^m in coefficient embedding.
  return ceil(max_V_inv*sum_s_pow_m)
  
#########################
## How to use and tests
#########################
#m = 2*3*5*7
#L.<z> = CyclotomicField(m)
#print("L has degree = ", L.degree())
#OL = L.maximal_order()
#max_V_inv = Vandermonde_inv(L)
#print("max_V_inv = ", max_V_inv)

#list_quotient = []
#set_random_seed(42)
#print("computing the quotient x_estimated/x_actual, where x_estimated is obtained by running estimate_s_pow_m, and x_actual is the actual infinity norm of s^m (the quotient should be >= 1)")
#print("we repeat this 100 times")
#for _ in range(100):
#  s = sum([ZZ.random_element()*z^i for i in range(L.degree())])
#  x = s*s.conjugate()
#  Q = estimate_s_pow_m(L, m, x, max_V_inv)
#  quotient = RR(Q/max([abs(xi) for xi in list(s^m)]))
#  list_quotient += [quotient]
#  if quotient < 1:
#    print("s = ", s)
#print("min of the ratios = ", min(list_quotient))
#print("max of the ratios = ", max(list_quotient))

#print("\n\nRunning estimate_vr with the three possible levels of heuristics:")
#print("heuristic = \'normal\': ", estimate_vr(L, max_V_inv, heuristic = "normal"))
#print("heuristic = \'conservative\': ", estimate_vr(L, max_V_inv, heuristic = "conservative"))
#print("heuristic = \'proven\': ", estimate_vr(L, max_V_inv, heuristic = "proven"))

## The upper bound seems very good asymptotically (max and min are within [1,2] for most power-of-prime cyclotomic fields I tried, and converging to 1 when the dimension increases; for "bad" conductors of the form 2*3*5*7*..., the lower bound is close to 1, but the upper bound grows a bit (13 for m = 2*3*5*7))
## Careful: for m = 512, I found some s for which the quotient was 0.999999999938942 < 1 (3 out of 500 tested)
## e.g., s =  -z^255 - z^254 - z^252 + 2*z^250 - 5*z^249 + z^248 - 6*z^247 - 3*z^246 + z^244 - 14*z^243 + z^242 + z^241 - z^240 + z^239 + z^238 + z^237 + 5*z^235 + z^233 + z^232 - 2*z^231 - 6*z^230 - z^229 - z^228 - z^227 + z^226 + z^225 + 2*z^223 - 3*z^221 - z^218 - z^217 + z^216 + z^215 - z^214 + 2*z^213 - z^212 - z^211 + z^210 + 2*z^209 + z^208 - z^207 - 6*z^206 - 2*z^205 - z^204 + z^203 + 2*z^199 + 4*z^198 + 2*z^196 + z^195 + z^194 - z^193 - z^191 - z^190 + 2*z^189 - z^188 - 3*z^186 + 4*z^183 + 31*z^182 - z^181 - 3*z^180 - 15*z^179 - z^178 + 11*z^177 + 3*z^176 - 4*z^175 - 4*z^174 - z^173 + z^172 - z^171 - 3*z^170 - z^169 + 5*z^168 - 2*z^167 + 4*z^166 - 8*z^165 - z^164 - z^163 - z^162 - 10*z^161 + 3*z^160 - z^159 + z^158 - 54*z^157 - 3*z^156 - 2*z^154 - z^153 - z^152 + z^151 - z^147 + 6*z^146 - 2*z^145 + z^144 + 5*z^143 + 2*z^142 - 9*z^141 - 5*z^140 + 5*z^138 - z^137 + 2*z^136 + z^135 + z^134 - 7*z^131 - 23*z^130 + z^129 + 2*z^128 - z^127 - z^126 - z^124 - 3*z^123 + 6*z^122 + z^121 - z^120 + 2*z^119 + 2*z^117 - z^116 + z^114 + 4*z^113 - z^111 - 3*z^110 + z^109 - z^107 + z^106 + z^105 + 2*z^104 + 2*z^103 + 5*z^102 + z^101 - 2*z^100 + z^99 - z^97 + 3*z^96 + z^95 - 2*z^94 - z^93 + 2*z^92 - z^91 - z^90 + z^89 + 8*z^88 + 4*z^87 + 18*z^86 + z^83 + z^82 + z^81 - z^80 + z^79 + z^78 + z^77 - 2*z^76 - z^75 - 67*z^74 - 2*z^73 + z^72 - z^71 + z^69 + 2*z^68 + z^67 - 3*z^66 + z^65 + 5*z^64 + z^63 - 4*z^61 + z^60 + 2*z^59 - z^56 - z^55 - 4*z^54 + 2*z^52 - 3*z^51 + z^49 - 4*z^48 + z^47 + 3*z^46 - 4*z^45 + z^44 - z^43 - z^42 - 4*z^40 - 3*z^39 - 2*z^37 + 10*z^36 - z^35 + z^34 + 46*z^33 + 6*z^32 - z^30 + z^29 + z^28 - z^27 - 2*z^26 - z^25 - 9*z^24 + 8*z^23 - 20*z^22 - z^21 - z^20 + 3*z^18 - z^17 - z^15 + z^14 - z^13 - z^12 - z^10 + 18*z^8 - 3*z^7 - z^5 - 2*z^4 - 4*z^2 + 3*z - 1
