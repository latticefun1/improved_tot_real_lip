##########
# Copyright 2024, Guilhem Mureau, Alice Pellet-Mary, Heorhii Pliatsok,
# Alexandre Wallet

# This file is part of the algorithm to solve Module-LIP in rank 2
# over totally real fields, called for referencing reason
# ModLipAttack. ModLipAttack is free software: you can redistribute it
# and/or modify it under the terms of the GNU Affero Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.  ModLipAttack is
# distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero Public License
# for more details.  You should have received a copy of the GNU Affero
# Public License along with ModLipAttack. If not, see
# <https://www.gnu.org/licenses/>

##########

####################################################
## This file contains the main function of
## the Gentry-Szydlo algorithm, called
## gentry_szydlo. 
## This algorithm takes as input a principal ideal
## I = s*OL, living in a cyclotomic number field L
## (OL is the ring of integers of L), and the 
## relative norm x = s*bar(s) of one generator.
## It recovers s (up to multiplication by a root
## of unity) in polynomial time.
## The function gentry_szydlo below call other
## functions available in the other files of the
## repository Gentry_Szydlo
#####################################################

## Loading the files containing the various functions needed for the algorithm
load("polynomial_chain.sage")
load("nf_root.sage")
load("estimate_size_prime.sage")


def gentry_szydlo(I, x, L, heuristic = "normal", path_to_pari = None, path_to_GS = "./", verbose = False):

## Input :  L is a cyclotomic number field
##          I is a principal ideal, generated by some (unknown) element v in OL (ring of integers of L)
##          x = v*bar(v)
##          heuristic is a string which can be either "normal" (default), "conservative" or "proven". This provides three trade-offs between the running time of the algorithm and the guarantee that the output is correct. Choosing heuristic = "normal" will provide the fastest algorithm, but it might fail sometimes (though this is still very unlikely, and we never experienced it). On the other hand, choosing heuristic = "proven" guarantees that the result is correct (up to implementation mistakes...), but will take way longer to run. More details on the three modes can be found in the comments of the function estimate_vr in the file estimate_size_prime.sage. If a very small probability of error is not an issue for you (e.g., if you can test a posteriori that the output of the algorithm was correct), we stongly suggest keeping the default value, namely: heuristic = "normal".
##          path_to_pari is a string or is None (default: None). When it is set to a string, it should be the path to an executable of gp, which sage will try to run, instead of running its internal pari's version (useful if you have an insallation of pari with version >= 2.16 on your computer and if the version accessible by sage is < 2.16 (check this by typing 'pari.version()' in sage)).
##          path_to_GS is the path from the current directory (where Sage is run) to the directory containing the Gentry-Szydlo code files. This field is used only when path_to_pari is not None.
##          verbose is a boolean (default = False). If verbose = True, some information will be printed while the code is executed (useful in debugg mode).
## Output : an element w such that x = w*bar(w) and I = w*OL if it exists
##          None if no such element w exists (i.e., the input was ill-formed)

    ## Computing the various parameters needed internally (m_bis, min_P and min_Q)
    max_V_inv = Vandermonde_inv(L)
    m = L.conductor()
    m_bis = m ## double m if it is odd, otherwise there are no solutions to the good_primes function (in file polynomial_chain.sage)
    if m_bis%2 == 1: 
      m_bis = 2*m_bis
    min_Q = (3*estimate_s_pow_m(L, m_bis, x, max_V_inv)) # we need to take Q bigger than twice the output of estimate_s_pow_m. We multiply by 3 instead of 2 to make sure our result is correct, even when there are some small numerical precision errors in estimate_s_pow_m
    min_P = 2*estimate_vr(L, max_V_inv, heuristic = heuristic) #the size of P1 and P2 have much more impact on the running time of the algorithm than the size of Q, hence, we keep the smallest factor 2 here
    if verbose:
      print("log(min_Q,2) = ", RR(log(min_Q,2)))
      print("min_P = ", min_P)
    I_pari = pari(I)
    ## compute s^m
    small_pow = smallpow_modQ(I_pari,x,min_Q,m_bis,min_P, L, path_to_pari = path_to_pari, path_to_GS = path_to_GS, verbose = verbose)
    ## compute s from s^m (this may fail if the input was ill-formed)
    try:
      res = number_field_root(small_pow,m_bis,L, verbose = verbose)
    except ValueError:
      if verbose:
        print("\nThe input was incorrect, no solution was found!\n")
        res = None
    return(res)


##########################
## How to use
##########################

## See file test_Gentry_Szydlo.sage

